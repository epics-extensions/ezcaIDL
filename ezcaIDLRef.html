<!-- This file was generated by mk_html_help.pro -->
<html>
 
<head>
<TITLE>Extended IDL Help</TITLE>
</head>
 
<body>
<H1>Extended IDL Help</H1>
<P>
This page was created by the IDL library routine 
<CODE>mk_html_help</CODE>.  For more information on 
this routine, refer to the IDL Online Help Navigator 
or type: <P>
<PRE>     ? mk_html_help</PRE><P>
at the IDL command line prompt.<P>
<STRONG>Last modified: </STRONG>Thu Jul 20 22:24:26 1995.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#CACHECKMONITOR">CACHECKMONITOR</A>
<LI><A HREF="#CACLEARMONITOR">CACLEARMONITOR</A>
<LI><A HREF="#CADEBUG">CADEBUG</A>
<LI><A HREF="#CAENDGROUP">CAENDGROUP</A>
<LI><A HREF="#CAERROR">CAERROR</A>
<LI><A HREF="#CAGET">CAGET</A>
<LI><A HREF="#CAGETCONTROLLIMITS">CAGETCONTROLLIMITS</A>
<LI><A HREF="#CAGETCOUNTANDTYPE">CAGETCOUNTANDTYPE</A>
<LI><A HREF="#CAGETENUMSTRINGS">CAGETENUMSTRINGS</A>
<LI><A HREF="#CAGETGRAPHICLIMITS">CAGETGRAPHICLIMITS</A>
<LI><A HREF="#CAGETPRECISION">CAGETPRECISION</A>
<LI><A HREF="#CAGETRETRYCOUNT">CAGETRETRYCOUNT</A>
<LI><A HREF="#CAGETSTATUS">CAGETSTATUS</A>
<LI><A HREF="#CAGETTIMEOUT">CAGETTIMEOUT</A>
<LI><A HREF="#CAGETUNITS">CAGETUNITS</A>
<LI><A HREF="#CAPUT">CAPUT</A>
<LI><A HREF="#CASETMONITOR">CASETMONITOR</A>
<LI><A HREF="#CASETRETRYCOUNT">CASETRETRYCOUNT</A>
<LI><A HREF="#CASETTIMEOUT">CASETTIMEOUT</A>
<LI><A HREF="#CASTARTGROUP">CASTARTGROUP</A>
<LI><A HREF="#CATRACE">CATRACE</A>
<LI><A HREF="#CAWIDGETADJUST">CAWIDGETADJUST</A>
<LI><A HREF="#CAWIDGETCLEARMONITOR">CAWIDGETCLEARMONITOR</A>
<LI><A HREF="#CAWIDGETSETMONITOR">CAWIDGETSETMONITOR</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="CACHECKMONITOR">
<H2>CACHECKMONITOR</H2></A>
<A HREF="#CACLEARMONITOR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caCheckMonitor

 PURPOSE:
	This function returns a non-zero value if there is a new (unread)
       monitor for this process variable, otherwise it returns zero.
       This function is particularly useful when a caGet() operation is
       expensive in time, e.g. reading large arrays.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	state = caCheckMonitor(pvname)

 INPUTS:
	pvname: The name of the process variable on which to check the monitor.

 OUTPUTS:
       The function return value is zero if no new monitor value is available,
       and non-zero if a new monitor value is available.

 PROCEDURE:
	This routine uses ezcaNewMonitorValue(). The "type" parameter required
       by ezcaNewMonitorValue() is the native EZCA data type as determined 
       by caGetCountAndType().

 EXAMPLES:
       IDL> state = caCheckMonitor('test_ao1')

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CACLEARMONITOR">
<H2>CACLEARMONITOR</H2></A>
<A HREF="#CACHECKMONITOR">[Previous Routine]</A>
<A HREF="#CADEBUG">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caClearMonitor

 PURPOSE:
	This procedure clears a monitor on the specified process variable.
       It cancels the effect of caSetMonitor().

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	status = caClearMonitor(pvname)

 INPUTS:
	pvname: The name of the process variable on which to clear the monitor.

 OUTPUTS:
       The function return value of caClearMonitor is a status value.  The
       status is 0 if the routine was successful (i.e. the process variable 
       exists) and non-zero if the routine failed.

 PROCEDURE:
	This routine uses ezcaClearMonitor(). The "type" parameter required
       by ezcaClearMonitor is the native EZCA data type as determined 
       by caGetCountAndType().

 EXAMPLES:
       IDL> status = caClearMonitor('test_ao1')

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CADEBUG">
<H2>CADEBUG</H2></A>
<A HREF="#CACLEARMONITOR">[Previous Routine]</A>
<A HREF="#CAENDGROUP">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caDebug

 PURPOSE:
	This procedure turns the EZCA debugging flag on or off. Turning on
       the debugging flag prints lots of information, which is mainly
       useful to developers.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	caDebug, state

 INPUTS:
	state:  state=1 turns debugging on, state=0 turns debugging off.

 OUTPUTS:
       None

 PROCEDURE:
	This routine uses ezcaDebugOn() and ezcaDebugOff().

 EXAMPLES:
       IDL> caDebug, 1     ; Turn on debugging
       setting Debug
       IDL> status = caGet('test_ao1', value)
       ca_pend_event(0.000010)
       --start end-of-prologue() report
       ****** Start State:
       AutoErrorMessage T InGroup F Debug T Trace F ErrorLocation LastOnly ListPrint
       LastOnly TimeoutSeconds 0.050000
       Workp : 9cf970 trashme F (nxt 0)
       Channel_avail_hdr 0 :
       ...
       ...
       IDL> caDebug, 0 ; Turn off debugging

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CAENDGROUP">
<H2>CAENDGROUP</H2></A>
<A HREF="#CADEBUG">[Previous Routine]</A>
<A HREF="#CAERROR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caEndGroup

 PURPOSE:
	This function ends an "asynchronous group". See caStartGroup for more
       information on asynchronous groups.
       caEndGroup flushes the queue of caGet and caPut calls and waits for
       replies from the channel access servers.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	stat = caEndGroup(status)

 INPUTS:
	None.

 OUTPUTS:
       The function return value is 0 if the operation was successful,
       otherwise it is the first encountered non-successful return code.
       The optional status parameter can be used to return the status code 
       of each operation in the group.

 OPTIONAL OUTPUT PARAMETERS:
       status: If this optional parameter is present then it returns a
               array of status information, one for each channel access
               call in the group.

 COMMON BLOCKS:
       EZCA_COMMON contains a flag (ingroup) which indicates if we
       are currently in an asynchronous group. This routine clears that flag.

 PROCEDURE:
	If the status parameter is present then this routine uses
       ezcaEndGroupWithReport().  If the parameter is not present then
       the routine calls ezcaEndGroup().

 RESTRICTIONS:
       When the status parameter is present, and ezcaEndGroupWithReport() is
       called, there is no way to know in advance how many status values
       will be returned.  This routine passes a status array with 1024
       elements, and then truncates it to the actual length.  The maximum
       number of status values which can be retrieved is thus 1024. No errors
       will occur if an asynchronous group has more than 1024 calls, but
       only the first 1024 status values can be obtained. 
       This is probably sufficient for most applications!

 EXAMPLES:
       IDL> caStartGroup
       IDL> status = caget('test_ao1.SCAN', scan)
       IDL> status = caget('test_mca1.ERTM', ertm)
       IDL> ; Print out values - they will be zero.
       IDL> help, scan, ertm
       IDL> status = caEndGroup()
       IDL> ; Print out values after executing caEndGroup, they are non-zero
       IDL> help, scan, ertm
       Output:
           SCAN            INT       =        0
           ERTM            FLOAT     =      0.000000
           SCAN            INT       =        6
           ERTM            FLOAT     =       7.10000

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CAERROR">
<H2>CAERROR</H2></A>
<A HREF="#CAENDGROUP">[Previous Routine]</A>
<A HREF="#CAGET">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caError

 PURPOSE:
	This procedure controls error printing and returns error strings.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	caError, err_string, /ON, /OFF, /PRINT, prefix=prefix

 INPUTS:
       None

 KEYWORD PARAMETERS:
       /ON
           Setting this switch turns on automatic error message printing
           on stdout.  Automatic printing is initially enabled.

       /OFF
           Setting this switch turns off automatic error message printing
           on stdout.

       /PRINT
           Setting this switch prints the last error message on stdout.

       prefix=prefix
           The prefix keyword can be used to pass a string which is prefixed
           to error messages printed with /PRINT or fetched via the optional
           output parameter.

 OPTIONAL OUTPUT PARAMETERS:
	err_string:
           If this parameter is present then it will contain the text of the
           last error message.

 COMMON BLOCKS:
       EZCA_COMMON contains a flag (ingroup) which indicates if we
       are currently in an asynchronous group. This routine tests that flag.

 PROCEDURE:
	This routine uses ezcaPerror(), ezcaAutoErrorMessageOn(), 
       ezcaAutoErrorMessageOff(), and ezcaGetErrorString()

 EXAMPLE:
       IDL> ; Define a prefix and turn on error messages
       IDL> caError, prefix='My program', /ON  
       IDL> ; Fetch the last error message
       IDL> caError, err_string

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CAGET">
<H2>CAGET</H2></A>
<A HREF="#CAERROR">[Previous Routine]</A>
<A HREF="#CAGETCONTROLLIMITS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caGet

 PURPOSE:
	This function reads the value of a Channel Access process variable.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	Status = caGet(pvname, value, /string, max=n)

 INPUTS:
	pvname:	The name of the process variable for which the value is to
               be returned.

 KEYWORD PARAMETERS:
	STRING:	Set this flag to force caGet to return a string, rather than
               a number.  This flag is particularly useful when the native
               channel access data type is ENUM (3), since the string is
               more descriptive than the number.

	MAX:    This keyword parameter is used to limit the number of
               values returned by caGet. caGet normally returns the native
               element count for a process variable. Setting MAX to a
               number less than this will cause caGet to return only the
               first MAX values in the array.

 OUTPUTS:
	value:  The value of the process variable. By default, caGet returns
               "value" with the native data type and number of elements
               of the process variable. It determines this information by
               calling caGetCountAndType().  Note that if caGet is called
               after calling caStartGroup but before calling caEndGroup then
               the IDL variable "value" is created, but will not actually
               contain the data until caEndGroup is called.

       The function return value of caGet is a status value.  The
       status is 0 if the routine was successful (i.e. the process variable 
       exists) and non-zero if the routine failed.  If caGet is called from
       within an asynchronous group then the status return only indicates
       whether the operation was successfully queued.

 COMMON BLOCKS:
       EZCA_COMMON contains a flag (ingroup) which indicates if we
       are currently in an asynchronous group. This routine tests that flag.

 SIDE EFFECTS:
	This routine will causes a channel access search to take place if 
       this is the first time this process variable has been referenced. It
       performs a ca_get, unless called as part of an asynchronous group.

 RESTRICTIONS:
       There are two important restrictions which must be kept in mind when
       calling caGet from inside a "group", i.e. after calling caStartGroup 
       and before calling caEndGroup.

       1) The IDL "value" variable (i.e. the second parameter
       passed to caGet) must not be "re-used" or deleted before the call to
       caEndGroup. The reason for this is that EZCA has been passed the 
       address of this variable as the location in which the data is to be 
       copied when caEndGroup is called. Thus, this location must still 
       point to a valid memory location when caEndGroup is called.  
       If the "value" variable is re-used then IDL's behavior is 
       unpredictable, and bus errors/access violations could occur.

       2) When using caGet to read strings, the data type returned will be
       a byte array, rather than a string.  The reason has to do with the 
       manner in which IDL passes strings, which requires that EZCA actually
       be passed pointers to byte arrays. When caGet is called outside of a
       group it automatically converts the byte array to a string before
       returning the value. However when caGet is called inside of a group 
       it cannot perform this conversion, since it cannot be done until after 
       the data is read, which does not occur until caEndGroup is called. 
       Thus, it is the user's responsibility to convert the data from a byte 
       array to a string after calling caEndGroup. This is done very simply 
       with the string() function. For more information see the example below.

 PROCEDURE:
	This routine uses ezcaGet().

 EXAMPLES:
       IDL> ; The following is an example of a single caGet
       IDL> status = caGet('test_mca1.VAL', value)

       IDL> ; The following is an example of a valid grouped operation
       IDL> ; It also shows how to handle strings.
       IDL> caStartGroup
       IDL> status = caGet('test_mca1.VAL', mca_value)
       IDL> status = caGet('test_vme1.DESC', vme_desc) ; This is a string PV
       IDL> status = caEndGroup()
       IDL> vme_desc = string(vme_desc)    ; Convert from byte array to string

       IDL> ; The following is an example of an INVALID grouped operation
       IDL> caStartGroup
       IDL> status = caGet('test_mca1.VAL', mca_value)
       IDL> status = caGet('test_vme1.VAL', vme_value)
       IDL> mca_value=0
       IDL> ; We have redefined mca_value, so the previous location is
       IDL> ; undefined. NO NOT DO THIS!
       IDL> status = caEndGroup()

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CAGETCONTROLLIMITS">
<H2>CAGETCONTROLLIMITS</H2></A>
<A HREF="#CAGET">[Previous Routine]</A>
<A HREF="#CAGETCOUNTANDTYPE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caGetControlLimits

 PURPOSE:
	This procedure reads the control limits for the specified channel
       access process variable.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	status = caGetControlLimits(pvname, low, high)

 INPUTS:
	pvname: The name of the process variable from which to read the 
               control limits.

 OUTPUTS:
       low:    The low control limit (double).

       high:   The high control limit (double).

       The function return value of caGetControlLimits is a status value.  The
       status is 0 if the routine was successful (i.e. the process variable 
       exists) and non-zero if the routine failed.

 PROCEDURE:
	This routine uses ezcaGetControlLimits(). 

 EXAMPLE:
       IDL> status = caGetControlLimits('test_ao1', low, high)

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CAGETCOUNTANDTYPE">
<H2>CAGETCOUNTANDTYPE</H2></A>
<A HREF="#CAGETCONTROLLIMITS">[Previous Routine]</A>
<A HREF="#CAGETENUMSTRINGS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caGetCountAndType

 PURPOSE:
	This function returns the number of elements and data type of a 
       Channel Access process variable.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	Status = caGetCountAndType(pvname, count, type)

 INPUTS:
	pvname:	The name of the process variable for which information is to
               be returned.

 OUTPUTS:
	count:  The number of elements in the process variable. This is 1 for
               scalar process variables and more than 1 for arrays.

       type:   This is a 3 element array containing information about the data
               type of the process variable.
               type(0) = Channel access data type as defined in "cadef.h"
               type(1) = EZCA data type as defined in "ezca.h"
               type(2) = IDL/PV-WAVE data type as defined in size()
               These data types are as follows:

               Name    Channel Access      EZCA        IDL/PVWAVE
               String      0                 1             7
               Short       1                 2             2
               Float       2                 4             4
               Enum        3                 2 (short)     2 (short)
               Byte        4                 0             1
               Long        5                 3             3
               Double      6                 5             5

   The function return value of caGetCountAndType is a status value.  The
   status is 0 if the routine was successful (i.e. the process variable exists)
   and non-zero if the routine failed.

 SIDE EFFECTS:
	This routine will cause a Channel Access search to take place if this is
       the first time this process variable has been referenced.

 RESTRICTIONS:
       The channel access data type enum is mapped to EZCA and IDL short
       data types.  However, application programs can use this routine to 
       determine if the native channel access data type is enum, and then
       use caGet(pvname, value, /string) to read the string equivalent of the 
       process variable. Programs can also use 
       caGetEnumStrings(pvname, strings) to read the strings for the all of
       the possible values of an enum process variable.

 PROCEDURE:
	This routine uses ezcaPvToChid() and then ca_element_count() and
       ca_field_type().
       Note that this routine always returns its values "immediately", even 
       if it is called between a caStartGroup and caEndGroup.

 EXAMPLE:
       IDL> status = caGetCountAndType('test_mca1.VAL', count, type)
       IDL> print, status
       0                       ; Status = success
       IDL> print, count
       2048                    ; Array with 2048 elements
       IDL> print, type
           5       3       3   ; Long data type
 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CAGETENUMSTRINGS">
<H2>CAGETENUMSTRINGS</H2></A>
<A HREF="#CAGETCOUNTANDTYPE">[Previous Routine]</A>
<A HREF="#CAGETGRAPHICLIMITS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caGetEnumStrings

 PURPOSE:
	This function returns all of the choice strings associated with a 
       Channel Access "enum" process variable. It is particularly useful
       for building menus of options.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	Status = caGetEnumStrings(pvname, strings)

 INPUTS:
	pvname:	The name of the process variable for which the enum strings
               are to be returned. The native channel access data type of
               this process variable must be enum (3).

 OUTPUTS:
	strings: A string array containing the strings for each possible
               value of the enum variable.

       The function return value of caGetEnumStrings is a status value.  The
       status is 0 if the routine was successful (i.e. the process variable 
       exists and is of type enum) and non-zero if the routine failed.

 SIDE EFFECTS:
	This routine causes a channel access read. It does not use the 
       grouping mechanism of EZCA, i.e. it always executes immediately.

 RESTRICTIONS:
       There must be less than 16 enum strings and they must each be less
       than 26 characters.

 PROCEDURE:
	This routine uses ezcaPvToChid and then ca_get() with a request type
       of DBR_GR_ENUM.  The functionality required by this routine is not
       presently provided directly in EZCA, although it should probably be 
       added.

 EXAMPLES:
       IDL> status = caGetEnumStrings('test_mca1.SCAN', strings)
       IDL> for i=0, n_elements(strings)-1 do print, strings(i)
       Passive
       Event
       I/O Intr
       10 second
       5 second
       2 second
       1 second
       .5 second
       .2 second
       .1 second

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CAGETGRAPHICLIMITS">
<H2>CAGETGRAPHICLIMITS</H2></A>
<A HREF="#CAGETENUMSTRINGS">[Previous Routine]</A>
<A HREF="#CAGETPRECISION">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caGetGraphicLimits

 PURPOSE:
	This procedure reads the graphic limits for the specified channel
       access process variable.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	status = caGetGraphicLimits(pvname, low, high)

 INPUTS:
	pvname: The name of the process variable from which to read the 
               graphic limits.

 OUTPUTS:
       low:    The low graphic limit (double).

       high:   The high graphic limit (double).

       The function return value of caGetGraphicLimits is a status value.  The
       status is 0 if the routine was successful (i.e. the process variable 
       exists) and non-zero if the routine failed.

 PROCEDURE:
	This routine uses ezcaGetGraphicLimits(). 

 EXAMPLE:
       IDL> status = caGetGraphicLimits('test_ao1', low, high)

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CAGETPRECISION">
<H2>CAGETPRECISION</H2></A>
<A HREF="#CAGETGRAPHICLIMITS">[Previous Routine]</A>
<A HREF="#CAGETRETRYCOUNT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caGetPrecision

 PURPOSE:
	This procedure reads the precision for the specified channel
       access process variable.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	status = caGetPrecision(pvname, precision)

 INPUTS:
	pvname: The name of the process variable from which to read the 
               precision.

 OUTPUTS:
       precision:  The precision (short).

       The function return value of caGetPrecision is a status value.  The
       status is 0 if the routine was successful (i.e. the process variable 
       exists) and non-zero if the routine failed.

 PROCEDURE:
	This routine uses ezcaGetPrecision(). 

 EXAMPLE:
       IDL> status = caGetPrecision('test_ao1', precision)

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CAGETRETRYCOUNT">
<H2>CAGETRETRYCOUNT</H2></A>
<A HREF="#CAGETPRECISION">[Previous Routine]</A>
<A HREF="#CAGETSTATUS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caGetRetryCount

 PURPOSE:
	This function returns the value of the EZCA retry count parameter.
       In conjunction with the EZCA Timeout parameter it determines how
       long EZCA will try to connect to a process variable before giving up.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	RetryCount = caGetRetryCount()

 INPUTS:
	None.

 OUTPUTS:
       The function return value of caGetRetryCount is the integer
       value of the EZCA RetryCount parameter.

 PROCEDURE:
	This routine uses ezcaGetRetryCount().

 EXAMPLES:
       IDL> print, caGetRetryCount()
       599

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CAGETSTATUS">
<H2>CAGETSTATUS</H2></A>
<A HREF="#CAGETRETRYCOUNT">[Previous Routine]</A>
<A HREF="#CAGETTIMEOUT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caGetStatus

 PURPOSE:
	This procedure reads the status parameters for a channel access 
       process variable.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	status = caGetStatus(pvname, timestamp, status, severity)

 INPUTS:
	pvname: The name of the process variable from which to read the 
               status parameters.

 OUTPUTS:
       timestamp: The timestamp of the last time the record was processed
               lonarr(2).

       status: The status flag (int).

       severity: The severity flag (int).

       The function return value of caGetStatus is a status value.  The
       status is 0 if the routine was successful (i.e. the process variable 
       exists) and non-zero if the routine failed.

 PROCEDURE:
	This routine uses ezcaGetStatus(). 

 EXAMPLE:
       IDL> status = caGetStatus('test_ao1', timestamp, status, severity)

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CAGETTIMEOUT">
<H2>CAGETTIMEOUT</H2></A>
<A HREF="#CAGETSTATUS">[Previous Routine]</A>
<A HREF="#CAGETUNITS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caGetTimeout

 PURPOSE:
	This function returns the value of the EZCA Timeout parameter. This
       value determines the time parameter passed to ca_pend_io() in EZCA.
       In conjunction with the EZCA RetryCount parameter it determines how
       long EZCA will try to connect to a process variable before giving up.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	timeout = caGetTimeout()

 INPUTS:
	None.

 OUTPUTS:
       The function return value of caGetTimeout is the floating point
       value of the EZCA Timeout parameter, in seconds.

 PROCEDURE:
	This routine uses ezcaGetTimeout().

 EXAMPLES:
       IDL> print, caGetTimeout()
       0.0500000

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CAGETUNITS">
<H2>CAGETUNITS</H2></A>
<A HREF="#CAGETTIMEOUT">[Previous Routine]</A>
<A HREF="#CAPUT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caGetUnits

 PURPOSE:
	This procedure reads the units string for the specified channel
       access process variable.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	status = caGetUnits(pvname, units)

 INPUTS:
	pvname: The name of the process variable from which to read the units.

 OUTPUTS:
       units:  The units (string).

       The function return value of caGetUnits is a status value.  The
       status is 0 if the routine was successful (i.e. the process variable 
       exists) and non-zero if the routine failed.

 COMMON BLOCKS:
       EZCA_COMMON contains a flag (ingroup) which indicates if we
       are currently in an asynchronous group. This routine tests that flag.

 PROCEDURE:
	This routine uses ezcaGetUnits(). 

 EXAMPLE:
       IDL> status = caGetUnits('test_ao1', units)

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CAPUT">
<H2>CAPUT</H2></A>
<A HREF="#CAGETUNITS">[Previous Routine]</A>
<A HREF="#CASETMONITOR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caPut

 PURPOSE:
	This procedure writes a new value to a channel access process variable.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	status = caPut(pvname, value)

 INPUTS:
	pvname:	The name of the process variable for which the new value
               is to be written

       value:  The new value to be written. In general this can be a scalar
               or array of any data type.  There are of course restrictions
               in that certain strings cannot be written to certain process
               variables, and some process variables cannot be passed arrays.

 OUTPUTS:
       The function return value of caPut is a status value.  The
       status is 0 if the routine was successful (i.e. the process variable 
       exists and a valid value was written) and non-zero if the routine 
       failed.

 PROCEDURE:
	This routine uses ezcaPut(). The "nelem" and "type" parameters passed
       to ezcaPut are determined from the IDL data type and number of elements
       of the "value" parameter passed to caPut(). Strings are converted to
       to byte arrays before being passed.

 RESTRICTIONS:
       None.   caPut can be called inside a group, i.e. after calling
               caStartGroup and before calling caEndGroup.  The "value"
               variable passed to caPut can be immediately re-used when
               inside a group, since EZCA copies it to a private location.

 EXAMPLES:
       IDL> ; Put a linear ramp (findgen()) to a waveform process variable.
       IDL> status = caPut('my_waveform.VAL', findgen(100))

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CASETMONITOR">
<H2>CASETMONITOR</H2></A>
<A HREF="#CAPUT">[Previous Routine]</A>
<A HREF="#CASETRETRYCOUNT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caSetMonitor

 PURPOSE:
	This procedure sets a monitor on the specified process variable.
       This causes a channel access callback to execute whenever the value
       of that process variable changes.  Subsequent calls to caGet() after
       calling caSetMonitor will read the values provided by the callbacks,
       rather than reading from the IOC.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	status = caSetMonitor(pvname)

 INPUTS:
	pvname: The name of the process variable on which to set the monitor.

 OUTPUTS:
       The function return value of caSetMonitor is a status value.  The
       status is 0 if the routine was successful (i.e. the process variable 
       exists) and non-zero if the routine failed.

 PROCEDURE:
	This routine uses ezcaSetMonitor(). The "type" parameter required
       by ezcaSetMonitor is the native EZCA data type as determined 
       by caGetCountAndType().

 EXAMPLES:
       IDL> status = caSetMonitor('test_ao1')
       IDL> status = caGet('test_ao1', value)

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CASETRETRYCOUNT">
<H2>CASETRETRYCOUNT</H2></A>
<A HREF="#CASETMONITOR">[Previous Routine]</A>
<A HREF="#CASETTIMEOUT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caSetRetryCount

 PURPOSE:
	This procedure sets the value of the EZCA RetryCount parameter.
       In conjunction with the EZCA Timeout parameter it determines how
       long EZCA will try to connect to a process variable before giving up.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	caSetRetryCount, retrycount

 INPUTS:
	RetryCount: The integer retry count.

 OUTPUTS:
       None

 PROCEDURE:
	This routine uses ezcaSetRetryCount().

 EXAMPLES:
       IDL> caSetRetryCount, 100

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CASETTIMEOUT">
<H2>CASETTIMEOUT</H2></A>
<A HREF="#CASETRETRYCOUNT">[Previous Routine]</A>
<A HREF="#CASTARTGROUP">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caSetTimeout

 PURPOSE:
	This procedure sets the value of the EZCA Timeout parameter. This
       value determines the time parameter passed to ca_pend_io() in EZCA.
       In conjunction with the EZCA RetryCount parameter it determines how
       long EZCA will try to connect to a process variable before giving up.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	caSetTimeout, timeout

 INPUTS:
	Timeout:  The timeout value in seconds (floating point).

 OUTPUTS:
       None

 PROCEDURE:
	This routine uses ezcaSetTimeout().

 EXAMPLES:
       IDL> caSetTimeout, .001

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CASTARTGROUP">
<H2>CASTARTGROUP</H2></A>
<A HREF="#CASETTIMEOUT">[Previous Routine]</A>
<A HREF="#CATRACE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caStartGroup

 PURPOSE:
	This procedure starts an "asynchronous group".  Within an asynchronous
       group all calls to caGet and caPut are asynchronous, i.e. they queue
       a request and return immediately without waiting for a reply from
       the channel access servers. Calling caEndGroup causes the queue to be 
       flushed and waits for the replies. The use of asynchronous 
       groups can greatly improve the efficiency of channel access. The user
       must be aware of the restrictions on caGet outlined under the
       description of that routine.

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	caStartGroup

 INPUTS:
	None.

 OUTPUTS:
       None

 COMMON BLOCKS:
       EZCA_COMMON contains a flag (ingroup) which indicates if we
       are currently in an asynchronous group. This routine sets that flag.

 PROCEDURE:
	This routine uses ezcaStartGroup().

 EXAMPLES:
       IDL> caStartGroup
       IDL> status = caget('test_ao1.SCAN', scan)
       IDL> status = caget('test_mca1.ERTM', ertm)
       IDL> ; Print out values - they will be zero.
       IDL> help, scan, ertm
       IDL> status = caEndGroup()
       IDL> ; Print out values after executing caEndGroup, they are non-zero
       IDL> help, scan, ertm
       Output:
           SCAN            INT       =        0
           ERTM            FLOAT     =      0.000000
           SCAN            INT       =        6
           ERTM            FLOAT     =       7.10000

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CATRACE">
<H2>CATRACE</H2></A>
<A HREF="#CASTARTGROUP">[Previous Routine]</A>
<A HREF="#CAWIDGETADJUST">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caTrace

 PURPOSE:
	This procedure turns the EZCA trace flag on or off. Turning on
       the trace flag prints lots of information which is mainly useful 
       to developers.  Setting the trace flag results in less
       verbose output than setting the debug flag (see caDebug).

 CATEGORY:
	EPICS Channel Access Interface

 CALLING SEQUENCE:
	caTrace, state

 INPUTS:
	state:  state=1 turns trace on, state=0 turns trace off.

 OUTPUTS:
       None

 PROCEDURE:
	This routine uses ezcaTraceOn() and ezcaTraceOff().

 EXAMPLES:
       IDL> caTrace, 1     ;Turn on trace
       setting Trace
       IDL> status = caGet('test_ao1', value)
       ca_pend_event(0.000010)
       find_channel() found >test_ao1<
       get_channel(): was able to find_channel()
       ca_pend_event(0.000010)
       ...
       ...
       IDL> caTrace, 0     ; Turn off trace

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers
	June 28, 1995	
</PRE><P>
<STRONG>(See ezcaIDL.pro)</STRONG><P>
<HR>
 
<A NAME="CAWIDGETADJUST">
<H2>CAWIDGETADJUST</H2></A>
<A HREF="#CATRACE">[Previous Routine]</A>
<A HREF="#CAWIDGETCLEARMONITOR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caWidgetAdjust

 PURPOSE:
       This is a general purpose routine for adjusting and monitoring a process
       variable. It creates widget which is appropriate for the data type 
       of "pv", i.e. a mutually exclusive menu for DBF_ENUM, a text entry 
       widget for DBF_STRING, and an editable slider widget for any numeric 
       data type. This routine can be called from the event handler of larger 
       applications when all that needs to be done is adjust the value of a 
       process variable.

 CATEGORY:
	EPICS channel access; IDL widgets

 CALLING SEQUENCE:
	caWidgetAdjust, pv, font=font, min=min, max=max, label=label, $
                       group=group

 INPUTS:
	pv:     The name of the process variable to be adjusted

 KEYWORD PARAMETERS:
	font:   This keyword can be used to specify a font to use.

	min:    This keyword can be used to specify a lower limit for the
               slider widget when adjusting numeric process variables.

	min:    This keyword can be used to specify an upper limit for the
               slider widget when adjusting numeric process variables.

       label:  This keyword can be used to put a descriptive label at the 
               top of the widget.

       group:  This keyword can be used to set the id of the parent widget. 
               If the widget specified by "group" is deleted, then the 
               widget created by CaWidgetAdjust will also be deleted.

 SIDE EFFECTS:
	This routine will start channel access monitoring of this process
       variable if there are not already other widgets monitoring this 
       process variable.

 PROCEDURE:
       Builds a top-level widget to adjust this process variable.

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers, July 20, 1995
</PRE><P>
<STRONG>(See ezcaIDLWidgets.pro)</STRONG><P>
<HR>
 
<A NAME="CAWIDGETCLEARMONITOR">
<H2>CAWIDGETCLEARMONITOR</H2></A>
<A HREF="#CAWIDGETADJUST">[Previous Routine]</A>
<A HREF="#CAWIDGETSETMONITOR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caWidgetClearMonitor

 PURPOSE:
	This function clears a channel access IDL widget monitor which was 
       set with caWidgetSetMonitor

 CATEGORY:
	EPICS channel access; IDL widgets

 CALLING SEQUENCE:
	status = caWidgetClearMonitor(pv, widget_id)

 INPUTS:
	pv:     The name of the process variable associated with this widget

       widget_id:  The widget ID of the widget which was called on monitors.

 OUTPUTS:
   The function return value of caWidgetClearMonitor is a status value.  The
   status is 0 if the routine was successful (i.e. the process variable exists)
   and non-zero if the routine failed.

 COMMON BLOCKS:
	caWidgetCommon:

 SIDE EFFECTS:
	This routine will stop channel access monitoring of this process
       variable if there are no other widgets monitoring this process variable.
	this entry.

 PROCEDURE:
	If this is the last widget monitoring this process variable then
       caClearMonitor is called.

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers, July 20, 1995
</PRE><P>
<STRONG>(See ezcaIDLWidgets.pro)</STRONG><P>
<HR>
 
<A NAME="CAWIDGETSETMONITOR">
<H2>CAWIDGETSETMONITOR</H2></A>
<A HREF="#CAWIDGETCLEARMONITOR">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	caWidgetSetMonitor

 PURPOSE:
	This function establishes a channel access monitor on a process
       variable.  It causes a widget event for widget_id to be generated
       whenever a monitor arrives for that process variable.

 CATEGORY:
	EPICS channel access; IDL widgets

 CALLING SEQUENCE:
	status = caWidgetSetMonitor(pv, widget_id, time=time)

 INPUTS:
	pv:     The name of the process variable to be monitored.

       widget_id:  The widget ID of the widget to be called on monitors.

 KEYWORD PARAMETERS:
	time:	The time interval between polling to check for new monitors.
               The default is 0.1 seconds.

 OUTPUTS:
       The function return value of caWidgetSetMonitor is a status value.
       The status is 0 if the routine was successful (i.e. the process 
       variable exists) and non-zero if the routine failed.

 COMMON BLOCKS:
	caWidgetCommon:

 SIDE EFFECTS:
	This routine will start channel access monitoring of this process
       variable if there are not already other widgets monitoring this 
       process variable.

 PROCEDURE:
       If this is the first time caWidgetSetMonitor has been called 
       then it creates a dummy (iconified) widget which runs a timer routine. 
       The timer routine periodically calls caCheckMonitor(pv) to determine 
       whether a channel access monitor has arrived for "pv". If a monitor 
       has occurred then an event will be sent to the widget whose ID is 
       specified by "widget_id". 
       The event structure is as follows:
       event = 
         { id         ; The widget ID which was passed to caWidgetSetMonitor
           top:       ; The top level widget in this hierarchy
           handler:   ; The widget handler routine
           name:      ; The name of the process variable for which a monitor 
                      ; has occurred.
         }
       When the event is sent, the event handler routine for the specified 
       widget will be called. Generally this routine look at the event.id 
       field to determine that this is a monitor event (rather than a mouse 
       event).  If the same event handler can receive monitor events from 
       more than one process variable, (because caWidgetSetMonitor was 
       called for several process variables) the event handler will then 
       look at the event.name field to determine which process variable 
       generated the monitor event.

       Typically the widget_id which is passed to caWidgetSetMonitor
       should be the id of a base widget. Base widgets cannot generate 
       events due to mouse clicks, etc. so the widget event handler routine 
       can distinguish monitor events from mouse events by looking at the 
       widget.id field. This is the same concept which is described in the 
       IDL documentation for timer events, e.g.
           widget_control, wid, timer=1.0

       caWidgetSetMonitor can be called for many different process variable 
       names and widget_ids. The widgets do not need to belong to the same 
       widget hierarchy. Multiple widgets can monitor the same process 
       variable, and the same widget can be used to monitor several process 
       variables.  Internally  caWidgetSetMonitor maintains a list of all 
       monitored process variables, and which widget_id(s) are to receive 
       events from each process variable.

 MODIFICATION HISTORY:
 	Written by:	Mark Rivers, July 20, 1995
</PRE><P>
<STRONG>(See ezcaIDLWidgets.pro)</STRONG><P>
<HR>
 
</body>
</html>
