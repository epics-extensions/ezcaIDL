<HTML>
<HEAD>
<TITLE>ezcaIDL User's Guide</TITLE>
</HEAD>

<BODY>
<H1>ezcaIDL User's Guide</H1>
<h2>Version 3.0</h2>
<EM>Mark Rivers<BR>
Center for Advanced Radiation Sources<BR>
University of Chicago<BR>
rivers@cars.uchicago.edu<BR>
September 27, 2001<BR>
</EM>                                

<H2>Table of Contents</H2>
<UL>
<LI><A HREF="#Overview">Overview</A>
<LI><A HREF="#Release">Release notes</A>
<LI><A HREF="#Procedures">Procedures and Functions</A>
<LI><A HREF="#Routines">List of Routines by Functional Group</A>
<LI><A HREF="#Related">Related Documentation</A>
<LI><A HREF="#Synchronous">Synchronous Groups</A>
<LI><A HREF="#Error">Error Handling</A>
<LI><A HREF="#Debugging">Debugging</A>
<LI><A HREF="#Files">Files</A>
<LI><A HREF="#Libraries">Required Support Libraries</A>
<LI><A HREF="#UnixSetup">Unix Setup</A>
<LI><A HREF="#VMSSetup">VMS Setup</A>
<LI><A HREF="#Examples">Examples</A>
<LI><A HREF="#Widgets">IDL Widgets</A>
</UL>
 
<H2><A NAME="Overview">Overview</A></H2>

ezcaIDL is a library of routines for
<A HREF="http://sslab.colorado.edu:2222/projects/IDL/idl_ssl_home.html">IDL</A> 
and <A HREF="http://www.vni.com/pvwave.dir/wavehome.html">PV-WAVE</A>
which provides an
interface to EPICS Channel Access through the EZCA and EzcaScan libraries.  
<P>
PV-WAVE and IDL are closely related packages which are described as 
<CITE>Data Visualization Tools</CITE>.  They consist of 
a general purpose interpreted language
with very good graphics routines. Although not described as tools for data
collection and control applications, their rapid prototyping capabilities and
sophisticated graphics make them a nice environment for these applications.
Both also provide easy to use widget toolkits for quickly developing GUI
applications.
<P>
Although there is nearly a one-for-one match between the routines in ezcaIDL 
and the EZCA and EzcaScan libraries, the syntax of the IDL routines is not
the same as the syntax of the corresponding EZCA and EzcaScan routines.  The reason for this
is that IDL is more "object oriented" and relieves the programmer of much of
the detailed bookkeeping required of the C programmer.  Thus for example,  the
IDL routine <CODE>caGet()</CODE> returns, by default, 
a value which has the native data type
and element count of the process variable.  This is not true of the
corresponding C routine <CODE>ezcaGet()</CODE>, which requires the user to
specify the data type and number of elements to be returned.
<P>

<H2><A NAME="Release">Release notes</A></H2>
<h3>
Version 3.0 28-Sep-2001&nbsp;</h3>
<p>This was a signficant rewrite.</p>
<UL>
<LI>No string variables are passed to the shareable
libraries in this version.  This was done
to simplify things, since there are now at least 4 different conventions
for passing strings to shareable libraries (PVWAVE, IDL prior to 5.1 on
Windows, IDL 5.1-5.4, and IDL 5.5 and later).  We now only pass byte
arrays, not strings.  This permits a single shareable library to be used
for any version of PV-WAVE or IDL.
<LI>There are now 2 constants in ezca_common, MAX_STRING_SIZE and
MAX_ENUM_STATES. These values are set to 40 and 16 respectively in
caInit.  It is now MANDATORY to call caInit before calling any other
routine in this file, preferably in the IDL_STARTUP file.
<LI>Reformatted a lot of the code, and used ENDIF and ENDFOR consistently
rather than simple END statements.
<LI>Added support for unsigned short and unsigned long integer data types.
</UL>

<H2><A NAME="Procedures">Procedures and Functions</A></H2>

PV-WAVE and IDL are similar to FORTRAN in that they have two types of routines,
procedures and functions. Procedure are similar to FORTRAN subroutines: they do
not return a value. Functions, as in C or FORTRAN, return a value.  ezcaIDL
uses functions for all EZCA routines which return either status or data.
Procedures are used for routines which return <CODE>void</CODE>, i.e. 
neither data nor status.

Procedure and function names are not case sensitive. Of course, the names of
channel access process variables <EM>are</EM> case sensitive and 
must be specified correctly.


<H2><A NAME="Routines">List of Routines by Functional Group</A></H2>

ezcaIDL consists of the following routines, grouped by functionality:
<UL>
<LI>Initialization routines
<PRE>
    caInit [,flag] [,help=help]
    String = caVersion()
</PRE>

<UL>
<LI>Routines which return information about process variables
<PRE>
    Status = caGet(pvname, value, /STRING, max_elements=max_elements)
    Status = caGetArray(pvnames, pdata, max=no, type=i, /TYPE, /EVENT)
    Status = caGetControlLimits(pvname, low, high)
    Status = caGetGraphicLimits(pvname, low, high)
    Status = caGetPrecision(pvname, precision)
    Status = caGetStatus(pvname, timestamp, status, severity)
    Status = caGetUnits(pvname, units)
    Status = caGetEnumStrings(pvname, strings)
    Status = caGetCountAndType(pvname, count, type)
    Status = caSearch(pvnames)
    String = caTimeStamp(pvname)
</PRE>

<LI>Routines which write new values to process variables
<PRE>
    Status = caPut(pvname, value)
    Status = caPutArray(pvname, pdata, /event)
</PRE>

<LI>Routines which control channel access timeouts
<PRE>
    Timeout = caGetTimeout()
    caSetTimeout, timeout
    RetryCount = caGetRetryCount()
    caSetRetryCount, retrycount
    caPendEvent [,time=0.001] [,help=help]
    caPendIO, time=time, list_time=list_time
</PRE>

<LI>Routines which control synchronous groups
<PRE>
    caStartGroup
    stat = caEndGroup(status)
</PRE>

<LI>Routines which control channel access monitors
<PRE>
    Status = caSetMonitor(pvname)
    Status = caClearMonitor(pvname)
    State = caCheckMonitor(pvname)
    Status = caMonitor(pvname, vals, num, overflow, op_keyword, type_keyword, max=no)
</PRE>

<LI>Routines which collect data with the EPICS scan record
<PRE>
    Status = caScan(name, pvnames, nonames, npts, vals, op_keyword, max=no)
</PRE>

<LI>Routines which control debugging and error messages
<PRE>
    caDebug, state
    caTrace, state
    caError, err_string, /ON, /OFF, /PRINT, prefix=prefix
    Status = caGetError(Pvname, Err)
</PRE>
</UL>


<H2><A NAME="Related">Related Documentation</A></H2>

In addition to this ezcaIDL Users' Guide the following documentation will be
useful to the IDL programmer using ezcaIDL.
<UL>
<LI>
<A HREF="ezcaIDLRef.html">ezcaIDL Reference Guide</A>
This document contains a detailed description of all of the ezcaIDL routines. 
It is extracted directly from the standard documentation headers for each 
routine in the source file <CODE>ezcaIDL.pro</CODE>.
<LI>
<A HREF="http://epics.aps.anl.gov/asd/controls/epics/manuals/EzCaPrimer/EzcaPrimer.html">EZCA Primer</A>
This document contains an overview of the EZCA C library, which is used by
ezcaIDL.
</UL>


<H2><A NAME="Synchronous">Synchronous Groups</A></H2>

Normally all ezcaIDL calls, such as <CODE>caGet()</CODE> and 
<CODE>caPut()</CODE>
wait for all required 
channel access operations to complete before they return.  This is often
convenient, but it is very inefficient if one wants to read/write a large
number of process variables. In this case it is much more efficient to submit a
group of channel access requests, and then wait for them all to complete.
<P>
ezcaIDL supports the concept of "synchronous groups" in the EZCA library.
A synchronous group is started by calling
<PRE>
    caStartGroup
</PRE>
Once a synchronous group is started, subsequent calls to routines like 
<CODE>caGet()</CODE>, <CODE>caPut()</CODE>, etc. 
simply queue a channel access operation, and do not actually
perform the channel access I/O.  Calling
<PRE>
    status = caEndGroup()
</PRE>
ends a synchronous group.  This causes all of the queued channel access calls
to be issued and waits for them to complete.
<P>
There are two important restrictions which must be kept in mind when calling
any of the <CODE>caGetxxx()</CODE> routines (e.g. <CODE>caGet()</CODE>, 
<CODE>caGetUnits()</CODE>,
<CODE>caGetControlLimits()</CODE>, etc.) from inside a synchronous group, 
i.e. after calling
<CODE>caStartGroup</CODE> and before calling <CODE>caEndGroup()</CODE>.
<P>
<OL>
<LI>The IDL variable(s) which contain the return data values 
must not be "re-used" or
deleted before the call to <CODE>caEndGroup()</CODE>. 
The reason for this is that EZCA has
been passed the addresses of these variables as the locations to which the data
are to be copied when <CODE>caEndGroup()</CODE> is called. 
Thus, these locations must still 
point to a valid memory location when <CODE>caEndGroup()</CODE> is called.  
<EM>If the output
variables are re-used then IDL's behavior is unpredictable, and bus
errors/access violations could occur.</EM> 
In practice, fatal errors have not been
observed, but they are possible.

<LI>When using <CODE>caGet()</CODE> to read strings, 
the data type returned will be a byte
array, rather than a string.  The reason has to do with the manner in which
IDL passes strings, which requires that EZCA actually be passed pointers to
byte arrays. When <CODE>caGet()</CODE> is called outside of 
a group it automatically
converts the byte array to a string before returning the value. However when
<CODE>caGet()</CODE> is called inside of a 
synchronous group it cannot perform this
conversion, since it cannot be done until after the data is read, which does
not occur until <CODE>caEndGroup()</CODE> is called.  
Thus, it is the user's responsibility
to convert the data from a byte array to a string after calling 
<CODE>caEndGroup()</CODE>.
This is done very simply with the <CODE>string()</CODE> function.
</OL>

The following is an example of a valid grouped operation. It also shows 
how to handle strings.
<PRE>
caStartGroup
status = caGet('test_mca1.VAL', mca_value)
status = caGet('test_vme1.DESC', vme_desc) ; This is a string PV
status = caEndGroup()
vme_desc = string(vme_desc)    ; Convert from byte array to string
</PRE>

The following is an example of an <EM>invalid</EM> grouped operation.
<PRE>
caStartGroup
status = caGet('test_mca1.VAL', mca_value)
status = caGet('test_vme1.VAL', vme_value)
mca_value=0
status = caEndGroup()
</PRE>
Note that <CODE>mca_value</CODE> was redefined before calling
<CODE>caEndGroup()</CODE>, so the previous location became
undefined. <STRONG>Do not do this!</STRONG>


<H2><A NAME="Error">Error Handling</A></H2>

All ezcaIDL routines which can generate errors return a status code to indicate
success or failure. 0 indicates success, any other value indicates failure.
These status codes are generally those returned by the routines in ezca.c, 
although
some errors are returned directly from routines in <CODE>ezcaIDL.pro</CODE> and 
<CODE>ezcaIDL.c</CODE>.
<P>
The EZCA routines will, by default, print brief diagnostic error messages when
errors occur.  These messages can be turned off by calling:
<PRE>
    caError, /OFF
</PRE>
A message describing the most recent error can be printed on stdout by calling:
<PRE>
    caError, /PRINT
</PRE>
A string describing the most recent error can be returned to the caller with:
<PRE>
    caErrror, err_string
</PRE>

For more information on error messages see the 
<A HREF="ezcaIDLRef.html#caError">description of 
caError in the ezcaIDL Reference Guide</A>


<H2><A NAME="Debugging">Debugging</A></H2>

Detailed trace information for the EZCA routines can be obtained by calling:
<PRE>
    caTrace, 1
</PRE>
This can be turned off by calling
<PRE>
    caTrace, 0
</PRE>

Even more detailed debugging information for the EZCA routines can be obtained 
by calling:
<PRE>
    caDebug, 1
</PRE>
This can be turned off by calling
<PRE>
    caDebug, 0
</PRE>


<H2><A NAME="Files">Files</A></H2>

ezcaIDL consists of the following files:
<DL>
<DT><CODE>ezcaIDL.c</CODE>
<DD>This file is a thin interface between IDL and PV-WAVE and EZCA and EzcaScan. It converts the
parameters passed by IDL <CODE>call_external()</CODE> or 
PV-WAVE <CODE>linknload()</CODE>
to the form
required by EZCA and EzcaScan.  It directly implements some functions which are not
provided in the EZCA library.  
These include <CODE>ezcaIDLGetCountAndType()</CODE>
and <CODE>ezcaIDLGetEnumStrings()</CODE>.  
This file is compiled and linked into a shareable
object file, typically <CODE>ezcaIDL.so</CODE> on Unix and 
<CODE>ezcaIDL.EXE</CODE> on VMS.

<DT><CODE>ezcaIDL.pro</CODE>
<DD>This file contains the IDL/PV-WAVE functions and procedures.

<DT><CODE>ezcaWidgets.pro</CODE>
<DD>This file contains routines which simplify the use of widgets in IDL
channel access applications. These routines only work with IDL, not with
PV-WAVE.

<DT><CODE>ezcaIDLGuide.html</CODE>
<DD>This documentation file.

<DT><A HREF="ezcaIDLRef.html"><CODE>ezcaIDLRef.html</CODE></A>
<DD>This document contains a detailed description of all of the routines. It is
extracted directly from the standard documentation headers for each routine
in <CODE>ezcaIDL.pro</CODE>.
</DL>


<H2><A NAME="Libraries">Required Support Libraries</A></H2>

ezcaIDL requires the following support libraries in order to build the shareable
object file.  Users who want to port ezcaIDL to another architecture need to
port these libraries first.
<PRE>
    extensions/src/ezca
    extensions/src/EzcaScan
    base/src/ca
    base/src/libCom
</PRE>

<H2><A NAME="UnixSetup">Unix Setup</A></H2>

The following additions to your <CODE>.login</CODE> file will facilitate 
the use of ezcaIDL.<PRE>
# Define an IDL or PV-WAVE startup file to be executed when IDL or PV-WAVE are
# started
setenv IDL_STARTUP ~/idl_startup.pro
setenv WAVE_STARTUP ~/wave_startup.pro
#
# Define the location of ezcaIDL.so so this file can be located
# no matter what the current default directory is. This needs to be modified
# according to where the .so file is placed on your system.
setenv EZCA_IDL_SHARE /usr/local/epics/extensions/bin/solaris/ezcaIDL.so
</PRE>

In the IDL or PV-WAVE startup files 
(<CODE>~/idl_startup.pro</CODE> or <CODE>~/wave_startup.pro</CODE> in
the preceeding example <CODE>.login</CODE> file) add the following lines

<PRE>
;
!QUIET=1             ; So things will compile without informational messages
.RUN ezcaIDL         ; For both IDL and PV-WAVE
.RUN ezcaIDLWidgets  ; For IDL widget users
caInit               ; To define some required constants
;
</PRE>


<H2><A NAME="VMSSetup">VMS Setup</A></H2>

The following additions to your <CODE>LOGIN.COM</CODE> file will 
facilitate the use of 
ezcaIDL.<PRE>
$! Define an IDL or PV-WAVE startup file to be executed when IDL or PV-WAVE 
$! are started
$ DEFINE IDL_STARTUP SYS$LOGIN:idl_startup.pro
$ DEFINE WAVE_STARTUP SYS$LOGIN:wave_startup.pro
$!
$! Define the location of ezcaIDL.EXE so this file can be 
$! located no matter what the current default directory is. 
$! These need to be modified according to where the .EXE file is placed on 
$! your system.
$ DEFINE ezcaIDL_EXE  PUBLIC_DISK:[PUBLIC.EPICS.EXTENSIONS.BIN]ezcaIDL.EXE
$ DEFINE EZCA_IDL_SHARE ezcaIDL_EXE
</PRE>

In the IDL or PV-WAVE startup files 
(<CODE>idl_startup.pro</CODE> or <CODE>wave_startup.pro</CODE> in
the preceeding example <CODE>login.com</CODE> file) add the following lines
<PRE>
;
!QUIET=1             ; So things will compile without informational messages
.RUN ezcaIDL         ; For both IDL and PV-WAVE
.RUN ezcaIDLWidgets  ; For IDL widget users
caInit
;
</PRE>


<H2><A NAME="Examples">Examples</A></H2>

The following examples illustrate how to use some of the routines in ezcaIDL.

<PRE>
; Create a sine wave array, write it to a waveform record, read it back again
; and plot it.

IDL&gt; name = &quot;idl_test:wf1&quot;
IDL&gt; status = caGetCountAndType(name, n, type)
IDL&gt; data = sin(dindgen(n) * 2 * !PI / (n-1))
IDL&gt; status = caPut(name, data)
IDL&gt; status = caGet(name, readback)
IDL&gt; plot, readback


; Print the list of valid values for the .SCAN field of a record as strings,
; one per line.
status = caGetEnumStrings('idl_test:ai1.SCAN', choices)
for i=0, n_elements(choices)-1 do print, choices(i)


; Print out the next 10 values for a process variable which is changing by
; waiting for monitor events.
;
pv = 'mlr_scanner'
status = caSetMonitor(pv)    ; Add a monitor on this pv
status = caGet(pv, data)     ; Read the value, which clears the monitor flag
for i=1, 10 do begin
   count = 0
   status = 0
   while (caCheckMonitor(pv) ne 0) and (count le 100) do begin
      wait, .01
      count = count + 1                     ; Assumes new monitors come faster
      if (count eq 100) then status = -1    ; than 1 per second
   endwhile
   if (status ne 0) then begin
      print, 'Monitor wait failed for ', pv
   endif else begin
      status = caGet(pv, data)
      print, 'New value = ', data
   endelse
endfor
status = caClearMonitor(pv)


; The following is an example of a synchronous group operation
; It also shows how to handle strings in synchronous groups.
caStartGroup
status = caGet('test_mca1.VAL', mca_value)
status = caGet('test_vme1.VAL', vme_value)
status = caGet('test_vme1.DESC', vme_desc) ; This is a string PV
status = caEndGroup()
vme_desc = string(vme_desc)    ; Convert from byte array to string
</PRE>


<H2><A NAME="Widgets">IDL Widgets</A></H2>

The file <CODE>ezcaIDLWidgets.pro</CODE> contains 3 routines which 
simplify the use of channel
access, and particularly channel access monitors, with the IDL widget toolkit.

<H3>caWidgetSetMonitor(name, widget_id, time=time)</H3>
This function first adds a monitor on 
process variable "name", using routine 
<CODE>caSetMonitor()</CODE>.
<P>
If this is the first time <CODE>caWidgetSetMonitor</CODE> has been called 
then it creates a
dummy (iconified) widget which runs a timer routine. The timer routine
periodically calls <CODE>caCheckMonitor(name)</CODE> to determine whether a
channel access monitor has arrived for "name". 
If a monitor has occurred then an
event will be sent to the widget whose ID is specified by "widget_id". 
<P>
The event structure is as follows:
<PRE>
    event = 
      { id         ; The widget ID which was passed to caWidgetSetMonitor
        top:       ; The top level widget in this hierarchy
        handler:   ; The widget handler routine
        name:      ; The name of the process variable for which a monitor has
                   ; occurred.
      }
</PRE>
When the event is sent, 
the event handler routine for the specified widget will
be called. Generally this routine look at the <CODE>event.id</CODE> 
field to determine that
this is a monitor event (rather than a mouse event).  If the same event handler
can receive monitor events from more than one process variable, (because
<CODE>caWidgetSetMonitor</CODE> was called for several process variables) 
the event handler
will then look at the <CODE>event.name</CODE> field to determine which 
process variable generated the monitor event.
<P>
Typically the widget_id which is passed to <CODE>caWidgetSetMonitor</CODE>
should be the id
of a base widget. Base widgets cannot generate events due to
mouse clicks, etc. so the widget event handler routine can distinguish monitor
events from mouse events by looking at the <CODE>widget.id</CODE> field. 
This is the same
concept which is described in the IDL documentation for timer events, e.g.
<PRE>
    widget_control, wid, timer=1.0
</PRE>

<CODE>caWidgetSetMonitor</CODE> can be called for many 
different process variable names and
widget_ids. The widgets do not need to belong to the same widget hierarchy.
Multiple widgets can monitor the same process variable, and the same widget can
be used to monitor several process variables.  Internally 
<CODE>caWidgetSetMonitor</CODE>
maintains a list of all monitored process variables, and which widget_id(s) are
to receive events from each process variable.
<P>
The "time" keyword to <CODE>caWidgetSetMonitor</CODE> can be 
used to control the time
interval between polling cycles. The default is 0.1 seconds.
<P>
This routine sounds complex, but in fact it is simple to use and greatly
simplifies the use of channel access monitors with IDL widget, since without it
each widget event routine would have to poll to detect the arrival of channel
access monitors. The following is a simple example of the use of this routine:

<PRE>
pro example_event, event
    common example_common, pv_name, widget_ids
    ; This is the event handler routine, called whenever any type of event
    ; (monitor, mouse, timer) occurs.
   case event.id of
        widget_ids.monitor: begin
            ; Read the new value and display it
            status = caGet(event.name, value, /string)
            widget_control, widget_ids.value, set_value=value
        end

        widget_ids.exit: begin
            t=CaWidgetClearMonitor(pv_name, widget_ids.monitor)
            widget_control, event.top, /destroy
       	end
   endcase
end

pro example, name
    common example_common, pv_name, widget_ids
    ; This is the main routine for the example. 
    ; It is passed the name of a process variable to monitor.
    ; It creates a simple screen with a value field for the monitored process 
    ; variable and an EXIT button
    widget_ids= { $
            monitor:    0L, $
            value:      0L, $
            exit:       0L }
    base=widget_base(title=&quot;Example&quot;, /column)  ; The base widget
    widget_ids.monitor=base                     ; The monitor widget id=base
    widget_ids.value=widget_text(base, xsize=20) ; Widget to display new value
    widget_ids.exit=widget_button(base, value=&quot;Exit&quot;)  ; Exit button
    widget_control, base, /realize              ; Display the widgets
    t=caWidgetSetMonitor(name, widget_ids.monitor); Call caWidgetSetMonitor
    pv_name = name                              ; Copy name to common
    xmanager, &quot;example&quot;, base                   ; Start the program
end
</PRE>


<H3>caWidgetClearMonitor(name, widget_id)</H3>

This routine cancels the effect of <CODE>caWidgetSetMonitor</CODE>.  
If there are no other
widgets monitoring this process variable then <CODE>caClearMonitor</CODE> 
is called to
completely remove the channel access monitor on this name.

<H3>CaWidgetAdjust(name, font=font, min=min, max=max, label=label, group=group)
</H3>

This is a general purpose routine for adjusting and monitoring a process
variable. It creates widget which is appropriate for the data type of "name",
i.e. a mutually exclusive menu for DBF_ENUM, a text entry widget for DBF_STRING
and an editable slider widget for any numeric data type. This routine can be
called from the event handler of larger applications when all that needs to be
done is adjust the value of a process variable.
<P>
<CODE>name</CODE> is the name of the process variable to be adjusted.
<P>
The <CODE>font</CODE> keyword can be used to specify a font to use.
<P>
The <CODE>min</CODE> and <CODE>max</CODE>
 keywords can be used to specify the upper and lower limits
of the slider widget when adjusting numeric process variables.
<P>
The <CODE>label</CODE> keyword can 
be used to put a descriptive label at the top of the
widget.
<P>
The <CODE>group</CODE> keyword can be 
used to set the id of the parent widget. If the 
widget specified by <CODE>group</CODE> is deleted, 
then the widget created by 
<CODE>CaWidgetAdjust</CODE> will also be deleted.


</BODY>
</HTML>
